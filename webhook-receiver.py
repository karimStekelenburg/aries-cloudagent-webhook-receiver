#!/usr/bin/env python3

import argparse
import asyncio
import aiohttp
from aiohttp import web
import json
import logging
from uuid import uuid4

app = web.Application()
app.msg_queue = asyncio.Queue()
routes = web.RouteTableDef()

# CLI Argument Setup
parser = argparse.ArgumentParser(
    prog='webhook-receiver',
    description="collects and cache's aca-py webhook calls until requested by controller."
    )
parser.add_argument(
    '-w', '--websocket',
    action='store_true',
    help='when passed, it will expose a websocket interface at http://HOST:PORT/ws'
    )
parser.add_argument(
    '-l', '--log',
    action='store',
    choices=['CRITICAL', 'ERROR', 'WARNING', 'INFO', 'DEBUG'],
    default='INFO',
    help='the log level'
    )

parser.add_argument(
    '--api-key',
    action='store',
    help='if passed, this will be used as the API key. (one will be generated by default)'
    )
parser.add_argument('--host', '-H', action='store', default='0.0.0.0')
parser.add_argument('--port', '-p', action='store', default=8080)
args = parser.parse_args()



class Topic:
    CONNECTIONS = 'connections'
    BASICMESSAGES = 'basicmessages'
    ISSUE_CREDENTIAL = 'issue_credential'
    PRESENT_PROOF = 'present_proof'

class Message:
    def __init__(self, topic: Topic, payload: dict):
        self.topic = topic
        self.payload = payload

    def to_json(self) -> str:
        return json.dumps(self.__dict__)


def print_startup_message(messages: list) -> None:
    # print server information
    print()  # some whitespace for zenness
    for msg in messages:
        logging.info(msg)
    print()

async def on_ws_connection(request):
    ws = web.WebSocketResponse()

    provided_key = request.headers['Authorization']
    await ws.prepare(request)

    if provided_key != args.api_key:
        logging.warning(f'denied connection attempt with invalid api key {provided_key}')
        await ws.close()
        return

    while not ws.closed:
        msg = await request.app.msg_queue.get()
        await ws.send_str(msg.to_json())
        
    return ws

@routes.post('/topic/connections/')
async def connections_handler(request):
    msg = Message(Topic.CONNECTIONS, await request.json())
    await request.app.msg_queue.put(msg)
    return web.Response(status=200)

@routes.post('/topic/basicmessages/')
async def basicmessages_handler(request):
    msg = Message(Topic.BASICMESSAGES, await request.json())
    await request.app.msg_queue.put(msg)
    return web.Response(status=200)

@routes.post('/topic/issue_credential/')
async def issue_credential_handler(request):
    msg = Message(Topic.ISSUE_CREDENTIAL, await request.json())
    await request.app.msg_queue.put(msg)
    return web.Response(status=200)

@routes.post('/topic/present_proof/')
async def present_proofs_handler(request):
    msg = Message(Topic.PRESENT_PROOF, await request.json())
    await request.app.msg_queue.put(msg)
    return web.Response(status=200)

@routes.get('/new-messages')
async def new_messages_handler(request):
    response = []
    while not request.app.msg_queue.empty():
        msg = await request.app.msg_queue.get()
        response.append(msg.to_json())

    return web.Response(body=json.dumps(response))

if __name__ == '__main__':

    server_info_messages = []

    logging.basicConfig(level=args.log, format='%(levelname)s - %(message)s')
    server_info_messages.append(f'log level:\t{args.log}')

    app.add_routes(routes)  # add routes

    if args.api_key is None:
        args.api_key = str(uuid4())
        logging.info('no api-key provided, generating one..')

    if args.websocket:
        app.add_routes([web.get('/ws', on_ws_connection)])  # add webdocket route
        server_info_messages.append(f'websocket enabled at:\t\tws://{args.host}:{args.port}/ws')

    server_info_messages.append(f'API Key:\t\t{args.api_key}')

    print_startup_message(server_info_messages)



    web.run_app(app, host=args.host, port=args.port)